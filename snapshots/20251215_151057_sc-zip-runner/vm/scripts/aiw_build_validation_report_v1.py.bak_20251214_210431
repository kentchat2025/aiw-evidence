#!/usr/bin/env python3
"""
AIW Validation Report Builder v1

- Reads live data from:
    - AIW_T_SIGNAL (SIM)
    - AIW_A_CREAMY_LAYER (SIM)
    - AIW_M_INSTRUMENT
- Builds JSON for FounderConsole /api/aiwealth/validation
  using the REAL universe, candidates & creamy layer.
"""

import argparse
import json
import os
import sqlite3
from datetime import date


DB_PATH = "/opt/ai-wealth/db/aiw.db"
ENV_CODE = "SIM"
OUTPUT_PATH = os.environ.get("OUTPUT_PATH", "/opt/founderconsole/runtime/aiw_validation_report.json")


def connect_db():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def get_counts(conn, run_date):
    cur = conn.cursor()

    # Total signals for this date/env
    cur.execute(
        """
        SELECT COUNT(*) AS cnt
        FROM AIW_T_SIGNAL
        WHERE ENV_CODE = ? AND RUN_DATE = ?
        """,
        (ENV_CODE, run_date),
    )
    total_candidates = cur.fetchone()["cnt"]

    # Distinct instruments in signals
    cur.execute(
        """
        SELECT COUNT(DISTINCT INSTRUMENT_ID) AS cnt
        FROM AIW_T_SIGNAL
        WHERE ENV_CODE = ? AND RUN_DATE = ?
        """,
        (ENV_CODE, run_date),
    )
    total_universe = cur.fetchone()["cnt"]

    # Creamy layer rows
    cur.execute(
        """
        SELECT COUNT(*) AS cnt
        FROM AIW_A_CREAMY_LAYER
        WHERE ENV_CODE = ? AND RUN_DATE = ?
        """,
        (ENV_CODE, run_date),
    )
    creamy_layer_count = cur.fetchone()["cnt"]

    # Profiles present in creamy
    cur.execute(
        """
        SELECT PROFILE_ID, COUNT(*) AS cnt
        FROM AIW_A_CREAMY_LAYER
        WHERE ENV_CODE = ? AND RUN_DATE = ?
        GROUP BY PROFILE_ID
        ORDER BY PROFILE_ID
        """,
        (ENV_CODE, run_date),
    )
    profile_rows = cur.fetchall()
    profiles = [r["PROFILE_ID"] for r in profile_rows]

    return (
        total_universe,
        total_candidates,
        creamy_layer_count,
        profiles,
    )


def load_creamy_trades(conn, run_date, max_trades_per_profile=5):
    """
    Load creamy layer rows joined with instrument master,
    and turn them into proposed_trades for Founder Console.
    """
    cur = conn.cursor()
    cur.execute(
        """
        SELECT
            c.PROFILE_ID,
            c.INSTRUMENT_ID,
            c.BROKER_CODE,
            c.DIRECTION,
            c.QUANTITY,
            c.ENTRY_PRICE,
            c.TARGET_PRICE,
            c.STOP_LOSS,
            c.CONFIDENCE,
            c.EXPECTED_RETURN_PCT,
            c.AI_RECOMMENDATION,
            c.AI_REASON,
            c.DISPLAY_RANK,
            m.SYMBOL,
            m.EXCHANGE,
            m.INSTRUMENT_TYPE
        FROM AIW_A_CREAMY_LAYER c
        LEFT JOIN AIW_M_INSTRUMENT m
            ON m.INSTRUMENT_ID = c.INSTRUMENT_ID
        WHERE
            c.ENV_CODE = ?
            AND c.RUN_DATE = ?
        ORDER BY
            c.PROFILE_ID,
            c.DISPLAY_RANK,
            c.INSTRUMENT_ID
        """,
        (ENV_CODE, run_date),
    )
    rows = cur.fetchall()

    proposed_trades = []
    per_profile_count = {}

    for r in rows:
        profile_id = r["PROFILE_ID"] or ""
        # Normalise profile for display (EQUITY_CONSERVATIVE -> CONSERVATIVE)
        profile_display = profile_id.replace("EQUITY_", "").upper() or profile_id

        # Limit trades per profile in the JSON to keep it readable
        count = per_profile_count.get(profile_id, 0)
        if count >= max_trades_per_profile:
            continue
        per_profile_count[profile_id] = count + 1

        symbol = r["SYMBOL"] or r["INSTRUMENT_ID"]
        exchange = r["EXCHANGE"] or "NSE"
        segment = r["INSTRUMENT_TYPE"] or "EQ"

        ai_reco = r["AI_RECOMMENDATION"] or r["DIRECTION"] or "HOLD"
        ai_reason = r["AI_REASON"] or "Creamy layer pick from SIM engine."

        trade = {
            "symbol": symbol,
            "segment": segment,
            "exchange": exchange,
            "profile": profile_display,
            "direction": r["DIRECTION"],
            "quantity": float(r["QUANTITY"]),
            "entry_price": float(r["ENTRY_PRICE"]),
            "target_price": float(r["TARGET_PRICE"]),
            "stop_loss": float(r["STOP_LOSS"]),
            "confidence": float(r["CONFIDENCE"]),
            "ai_recommendation": ai_reco,
            "show_for_manual_approval": True,
            "ai_reason": ai_reason,
            "broker": r["BROKER_CODE"],
        }
        proposed_trades.append(trade)

    return proposed_trades


def build_profile_broker_map(trades):
    """
    Infer default broker per profile from the first trade of that profile.
    """
    profile_broker_map = {}
    for t in trades:
        p = t["profile"]
        b = t["broker"]
        if p not in profile_broker_map and b:
            profile_broker_map[p] = b
    return profile_broker_map


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--date",
        dest="run_date",
        help="Run date (YYYY-MM-DD), defaults to today if not provided.",
    )
    args = parser.parse_args()

    if args.run_date:
        run_date = args.run_date
    else:
        run_date = date.today().isoformat()

    print(f"[AIW-VALIDATION] Building report for ENV={ENV_CODE}, RUN_DATE={run_date}")
    print(f"[AIW-VALIDATION] DB: {DB_PATH}")

    conn = connect_db()

    (
        total_universe,
        total_candidates,
        creamy_layer_count,
        profiles,
    ) = get_counts(conn, run_date)

    print(
        f"[AIW-VALIDATION] Signals: {total_candidates}, "
        f"creamy: {creamy_layer_count}, profiles: {len(profiles)}"
    )

    proposed_trades = load_creamy_trades(conn, run_date, max_trades_per_profile=5)
    print(f"[AIW-VALIDATION] Proposed trades in JSON: {len(proposed_trades)}")

    profile_broker_map = build_profile_broker_map(proposed_trades)

    payload = {
        "status": "OK",
        "mode": "simulation-control-run-v1",
        "aiwealth_backend_url": "https://aiwealth.kentechit.com",
        "checks": [
            "health_endpoint_ok",
            "dns_ok",
            "npm_routing_ok",
            "ssl_ok",
        ],
        "summary": {
            "run_date": run_date,
            "env": ENV_CODE,
            "total_universe": total_universe,
            "total_candidates": total_candidates,
            "creamy_layer_count": creamy_layer_count,
            "profiles": profiles,
            "profile_broker_map": profile_broker_map,
        },
        "proposed_trades": proposed_trades,
        "notes": [
            "Simulation control run v1 using DB-backed tables.",
            f"Universe = distinct instruments in AIW_T_SIGNAL for {run_date}.",
            f"Creamy layer = AIW_A_CREAMY_LAYER, ENV={ENV_CODE}, RUN_DATE={run_date}.",
            "Proposed trades are top-ranked creamy picks (limited per profile for readability).",
        ],
    }


    # -- AIW_CONFIDENCE_V2 --
    # Confidence must be 0..100 (to match auto_approve_min_confidence=70)
    # We compute it from entry/target/stoploss so it's never a constant.
    import re as _re

    def _aiw_confidence_0_100(entry, target, stop):
        try:
            entry = float(entry); target = float(target); stop = float(stop)
            if entry <= 0:
                return 50
            exp_pct  = ((target - entry) / entry) * 100.0
            down_pct = ((entry - stop) / entry) * 100.0
            rr = 0.0
            if entry > stop and (entry - stop) != 0:
                rr = (target - entry) / (entry - stop)

            score = 50.0
            # Reward: expected % (cap) + RR (cap)
            score += max(0.0, min(exp_pct, 12.0)) * 2.0         # up to +24
            score += max(0.0, min(rr, 3.0)) * 5.0               # up to +15
            # Penalty: too-wide stop (beyond 2%) increases risk
            score -= max(0.0, min(down_pct - 2.0, 10.0)) * 1.5  # up to -15

            score = int(round(max(1.0, min(score, 99.0))))
            return score
        except Exception:
            return 50

    # --- robust report object picker (avoid NameError) ---

    _report_obj = None

    for _nm in ("report","payload","out","resp","result","response","data"):

        _v = locals().get(_nm)

        if isinstance(_v, dict) and ("proposed_trades" in _v or "summary" in _v):

            _report_obj = _v

            break

    if _report_obj is None:

        _report_obj = {}

    for t in (_report_obj.get("proposed_trades") or []):

        entry  = t.get("entry_price")
        target = t.get("target_price")
        stop   = t.get("stop_loss")
        conf   = _aiw_confidence_0_100(entry, target, stop)
        t["confidence"] = conf  # 0..100 integer

        # Fix reason text if it contains "confidence 0.xx"
        r = t.get("ai_reason")
        if isinstance(r, str):
            def _repl(m):
                try:
                    frac = float(m.group(1))
                    frac = float(m.group(1))
                    return f"confidence {int(round(frac*100))}/100"
                except Exception:
                    return m.group(0)

            r2 = _re.sub(r"confidence\s+([0-9]*\.[0-9]+)", _repl, r)
            if "[CONF=" not in r2:
                r2 = r2.rstrip() + f" [CONF={conf}/100]"
            t["ai_reason"] = r2
    os.makedirs(os.path.dirname(OUTPUT_PATH), exist_ok=True)
    with open(OUTPUT_PATH, "w", encoding="utf-8") as f:
        # AIW_PATCH: ensure risk_bucket/expected_return_pct/rr_ratio
        def _aiw_rb_from_profile(prof: str) -> str:
            u = (prof or "").upper()
            if "ULTRA" in u: return "ULTRA_AGGRESSIVE"
            if "CONSERV" in u: return "CONSERVATIVE"
            if "AGGRESS" in u: return "AGGRESSIVE"
            if "BALANC" in u: return "BALANCED"
            if "DEFAULT" in u: return "BALANCED"
            return "BALANCED"

        def _aiw_f(x, default=0.0):
            try:
                return float(x)
            except Exception:
                return float(default)

        try:
            _pt = (report.get("proposed_trades") if isinstance(report, dict) else None) or []
            for t in _pt:
                prof = t.get("profile") or t.get("profile_id") or ""
                if t.get("risk_bucket") in (None, "", "None"):
                    t["risk_bucket"] = _aiw_rb_from_profile(prof)
                entry  = _aiw_f(t.get("entry_price"))
                target = _aiw_f(t.get("target_price"))
                sl     = _aiw_f(t.get("stop_loss"))
                exp = ((target-entry)/entry*100.0) if entry else 0.0
                down = ((entry-sl)/entry*100.0) if entry else 0.0
                rr = ((target-entry) / max(1e-9, (entry-sl))) if entry else 0.0
                if "expected_return_pct" not in t:
                    t["expected_return_pct"] = round(exp, 2)
                if "downside_pct" not in t:
                    t["downside_pct"] = round(down, 2)
                if "rr_ratio" not in t:
                    t["rr_ratio"] = round(rr, 2)
        except Exception:
            pass

        json.dump(payload, f, indent=2)

    conn.close()
    print(f"[AIW-VALIDATION] Report written to {OUTPUT_PATH}")


if __name__ == "__main__":
    main()
